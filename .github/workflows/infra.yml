name: Infra (Terraform)

on:
  push:
    branches: [ main, master ]
    paths:
      - 'terraform/**'
      - 'k8s/**'
      - '.github/workflows/infra.yml'
  pull_request:
    paths:
      - 'terraform/**'
      - 'k8s/**'
      - '.github/workflows/infra.yml'
  workflow_dispatch:

jobs:
  terraform-validate:
    name: Terraform Fmt & Validate
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.7

      - name: Check Terraform content
        id: check
        shell: bash
        run: |
          set -euo pipefail
          if find . -maxdepth 1 -name '*.tf' -type f -print0 | xargs -0 cat | awk 'NF{c=1} END{print (c?"true":"false")}' | tee /dev/stderr | grep -q true; then
            echo "has_content=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_content=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Terraform fmt (check)
        if: steps.check.outputs.has_content == 'true'
        run: terraform fmt -check -diff -recursive

      - name: Terraform init (no backend)
        if: steps.check.outputs.has_content == 'true'
        run: terraform init -backend=false -input=false

      - name: Terraform validate
        if: steps.check.outputs.has_content == 'true'
        run: terraform validate

      - name: Terraform plan (best-effort)
        if: steps.check.outputs.has_content == 'true'
        continue-on-error: true
        run: terraform plan -input=false -no-color

  k8s-apply:
    name: Apply Kubernetes Manifests
    runs-on: ubuntu-latest
    needs: []
    env:
      # Provide one of these via repo or org secrets/variables
      KUBE_CONFIG: ${{ secrets.KUBE_CONFIG || vars.KUBE_CONFIG || '' }}
      KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA || vars.KUBE_CONFIG_DATA || '' }}
      K8S_NAMESPACE: ${{ secrets.K8S_NAMESPACE || vars.K8S_NAMESPACE || 'default' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect k8s manifests
        id: detect
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p k8s || true
          # Find non-empty YAML files
          files=$(find k8s -type f \( -name '*.yml' -o -name '*.yaml' \) -size +0c | sort || true)
          if [ -n "$files" ]; then
            echo "found=true" >> "$GITHUB_OUTPUT"
            printf '%s\n' "$files" > manifest-list.txt
            echo "Manifests to apply:"; cat manifest-list.txt
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo "No non-empty k8s manifests found; skipping apply."
          fi

      - name: Setup kubectl
        if: steps.detect.outputs.found == 'true'
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.30.0'

      - name: Configure kubeconfig (direct)
        if: steps.detect.outputs.found == 'true' && env.KUBE_CONFIG != ''
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.kube
          printf "%s" "$KUBE_CONFIG" > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config current-context || true

      - name: Configure kubeconfig (base64)
        if: steps.detect.outputs.found == 'true' && env.KUBE_CONFIG == '' && env.KUBE_CONFIG_DATA != ''
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p ~/.kube
          printf "%s" "$KUBE_CONFIG_DATA" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl config current-context || true

      - name: Skip â€” no kubeconfig provided
        if: steps.detect.outputs.found == 'true' && env.KUBE_CONFIG == '' && env.KUBE_CONFIG_DATA == ''
        run: |
          echo "No KUBE_CONFIG or KUBE_CONFIG_DATA provided; skipping kubectl apply." >> "$GITHUB_STEP_SUMMARY"

      - name: kubectl apply
        if: steps.detect.outputs.found == 'true' && (env.KUBE_CONFIG != '' || env.KUBE_CONFIG_DATA != '')
        shell: bash
        run: |
          set -euo pipefail
          # Create namespace first if present
          if [ -f k8s/namespace.yml ] || [ -f k8s/namespace.yaml ]; then
            kubectl apply -f k8s/namespace.yml || kubectl apply -f k8s/namespace.yaml || true
          fi
          # Apply all manifests recursively
          kubectl apply -R -f k8s
          printf "Applied manifests to namespace '%s'\n" "$K8S_NAMESPACE" >> "$GITHUB_STEP_SUMMARY"

      - name: Check rollout (best-effort)
        if: steps.detect.outputs.found == 'true' && (env.KUBE_CONFIG != '' || env.KUBE_CONFIG_DATA != '')
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          echo "Checking deployment rollouts in namespace: $K8S_NAMESPACE"
          kubectl -n "$K8S_NAMESPACE" get deploy || exit 0
          kubectl -n "$K8S_NAMESPACE" rollout status deploy --timeout=120s
