name: Infra Deploy

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  terraform_apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: terraform
    env:
      TF_VAR_sql_password: ${{ secrets.SQL_ADMIN_PASSWORD }}
      TF_VAR_location: ${{ secrets.AZURE_LOCATION || vars.AZURE_LOCATION || 'austriaeast' }}
    outputs:
      kube_config_data: ${{ steps.export_kubeconfig.outputs.kube_config_data }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
          terraform_wrapper: false

      - name: Show Terraform version and path
        id: tfver
        run: |
          terraform version
          echo "TF_BIN=$(command -v terraform)" >> "$GITHUB_ENV"

      - name: Terraform Init (with backend)
        run: $TF_BIN init -input=false -upgrade

      - name: Terraform Apply
        run: $TF_BIN apply -auto-approve -lock=false -input=false

      #  Export AKS kubeconfig dynamically
      - name: Export AKS kubeconfig
        id: export_kubeconfig
        shell: bash
        run: |
          echo "Fetching AKS credentials dynamically..."
          az aks get-credentials \
            --resource-group rg-group1-austriaeast \
            --name grp1-aks \
            --file kubeconfig \
            --overwrite-existing

          echo "Encoding kubeconfig to base64..."
          KUBE64=$(base64 -w0 kubeconfig)
          echo "::set-output name=kube_config_data::$KUBE64"
          echo " Kubeconfig exported successfully."

  k8s_apply:
    name: Kubernetes Apply
    runs-on: ubuntu-latest
    needs: terraform_apply
    env:
      KUBE_CONFIG_DATA: ${{ needs.terraform_apply.outputs.kube_config_data }}
      K8S_NAMESPACE: app
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect k8s manifests
        id: detect
        run: |
          set -euo pipefail
          mkdir -p k8s || true
          files=$(find k8s -type f \( -name '*.yml' -o -name '*.yaml' \) -size +0c | sort || true)
          if [ -n "$files" ]; then
            echo "found=true" >> "$GITHUB_OUTPUT"
            echo "Manifests found:"
            cat <<< "$files"
          else
            echo "found=false" >> "$GITHUB_OUTPUT"
            echo " No manifests found, skipping."
          fi

      - name: Setup kubectl
        if: steps.detect.outputs.found == 'true'
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.30.0'

      #  Prepare kubeconfig from dynamic Terraform output
      - name: Prepare kubeconfig
        if: steps.detect.outputs.found == 'true'
        run: |
          mkdir -p ~/.kube
          echo "${KUBE_CONFIG_DATA}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config
          echo " Kubeconfig loaded successfully"
          kubectl cluster-info

      - name: Apply Kubernetes manifests
        if: steps.detect.outputs.found == 'true'
        run: |
          set -euo pipefail
          echo "Applying manifests to cluster..."

          if [ -f k8s/namespace.yaml ]; then
            kubectl apply -f k8s/namespace.yaml
          elif [ -f k8s/namespace.yml ]; then
            kubectl apply -f k8s/namespace.yml
          fi

          if [ -f k8s/ingress-controller/ingress-nginx.yaml ]; then
            echo "Deploying ingress-nginx controller..."
            kubectl apply -f k8s/ingress-controller/ingress-nginx.yaml
            kubectl -n ingress-nginx rollout status deploy/ingress-nginx-controller --timeout=240s
          fi

          kubectl apply -R -f k8s
          echo " All manifests applied successfully."

      - name: Verify Deployment Rollouts
        if: steps.detect.outputs.found == 'true'
        continue-on-error: true
        run: |
          kubectl -n "$K8S_NAMESPACE" get deploy || exit 0
          kubectl -n "$K8S_NAMESPACE" rollout status deploy --timeout=120s
